class SGTree{
    vector<int>seg;
    public:
    SGTree(int n){
        seg.resize(4 * n);
    }

    void build (int ind , int low, int high, vector<int> &arr){
        // TC = O(2 * n - 1) nearly O(n) 
        if(low ==  high){
            seg[ind] = arr[low];
            return;
        }

        int mid = (low + high)/2;
        build(2*ind+1, low, mid, arr);
        build(2*ind+2, mid + 1, high, arr);
        seg[ind] = min (seg[2 * ind + 1], seg[2*ind + 2]);
    }

    int query(int ind, int left, int right, int low, int high){
        // complete overlapping 
        if(low >= left && high <= right){
            return seg[ind];
        }
        // no overlapping
        if(high < left || right < low){                  // O(logn)
            return INT_MAX;
        }
        // partial overlapping 
        int mid = (low + high)/2;
        int lq = query(2 * ind+1, left, right, low, mid);
        int rq = query(2*ind+2, left, right, mid + 1, high);
        return min(lq, rq);
    }

    void update(int ind, int low, int high, int i, int val){
        if(low == high){
            seg[ind] = val;
            return;
        }
                                                                    //O(logn)
        int mid = (low + high)/2;
        if(i <= mid) update(2*ind + 1, low, mid, i, val);
        else update(2*ind + 2, mid + 1, high, i, val);
        seg[ind]= min(seg[2*ind + 1], seg[2*ind + 2]);
    }
};

int main(){
    int n ;
    cin>>n;
    vector<int>arr(n);
    for(int i = 0; i<n; i++){
        cin>>arr[i];
    }
    SGTree st(n);
    st.build(0, 0, n-1, arr);
    int q;
    cin>>q;
    while(q--){
        int type;
        cin>>type;
        if(type == 1){
            int l, r;
            cin>>l>>r;
            cout<<st.query(0, l, r, 0, n-1, arr)<<endl;
        } else{
            int i, val;
            cin>>i>>val;
            st.update(0, 0, n-1, i,val, arr);
            arr[i] = val;
        }
    }
}
